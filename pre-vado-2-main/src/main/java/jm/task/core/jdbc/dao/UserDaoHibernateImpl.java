package jm.task.core.jdbc.dao;

import jm.task.core.jdbc.model.User;
import jm.task.core.jdbc.util.Util;
import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.SessionFactory;

import javax.persistence.criteria.CriteriaQuery;
import java.util.List;

//в этом классе ты переопределяешь методы из интерфейса UserDao
public class UserDaoHibernateImpl implements UserDao {
    private final SessionFactory sessionFactory = Util.getConnection();
    //этот класс нам нужен, для того, чтобы управлять транзакциями в ручную!!(можно поставить аннотацию, чтобы было все автоматически, но это потом)
    private Session session = null;
    //собственно, этот класс нам нужен, для того, чтобы открывать и управлять сессиями, все просто как банный лист

    //необходима для переменных выше создать пустой конструктор, можно сделать вручную или использовать аннотацию, на твой вкус
    @Override
    public void createUsersTable() {
        //в этом методе, как ты уже понял мы создаем таблицу в бд, начнем по порядку:
        // 1) у переменной session мы приравниваем к переменной sessionFactory (так как у нее есть нужный нам метод), и у нее же используем методы:
        // 1.1) по открытию сессии, так как этот метод есть у session
        // 1.2) и началу транзакции, так как этот метод есть у sessionFactory
        // p.s при этих действиях идея попросит сделать явное преобразование
        // 2) открываем блок try, так как при дальнейших манипуляциях может вылетить ошибка HibernateException(его и ловим в catch, можно показать с помощью метода стектрейс)
        // 3) теперь в теле try у переменной session вызываем метод, который создаст нативный запрос и в тело его передадим sql, где будет создание таблицы, полей,
        // завершаем нашу красоту методом в конце который, цитирую его определние(вольное): используется в запросах, результатом которых является один единственный набор значений, я думаю ты понял о чем я))
        // 4) ну и под конец в теле блока try обращаемся к переменной session, вызываем метод, который закроет транзакцию
        // Первый метод готов, поздравляю ты стал генином

    }
    @Override
    public void dropUsersTable() {
        //опа вот и второй подошел метод, собственно, все аналогично, как и в методе createUsersTable(),
        // только теперь в нативном запросе ты дропаешь таблицу,
        // p.s sql помойка JpaRepository рулит, но это позже)

    }

    @Override
    public void saveUser(String name, String lastName, byte age) {
        //ну вот и третий подоспел, ну что, в параметры как порядочные любители аниме передадим поля(имя, возраст и тд, ну ты понял)
        // касательно а как делать, изи нахуй, первые два пункта как было написанно выше, а дальше проше:
        // у переменной session вызываем метод, который сохранит пользователя(в параметры передаем нового пользователя с параметрами, которые ты передал в параметры методы saveUser,
        // только нахуй попробуй передать в метод, который сохранит типо String ... это блять не надо, сразу переменные!),
        // ну и под конец, шлифанем пожухший 4 пункт выше, не забудь блять!
        // p.s есть такая тема, что типо в постгресе можно не передавать в параметры id а в mysql надо, короче, что-то типо того,
        // я сам не доконца выкупаю, короче разберись, ну можешь и хуй забить, но станешь сакурой автоматически, если ты понял о чем я

    }
    @Override
    public void removeUserById(long id) {
        //здесь как ты угадал, тоже самое что и в методе saveUser, ток у session. вызови метод, который будет удалять,
        // и передай в параметры, там немного другая техника, короче в параметрах обращаеся к переменной session, и у нее вызываешь гет и внего передаешь, User.class и id,
        // если не понял прочитай еще раз ток внимательно, я знаю, что ты когда читаешь нахуй, нихуя не читаешь клоун, без негатива

    }
    @Override
    public List<User> getAllUsers() {
        //ну здесь уже другая техника, поясню по факту, читай внимательно:
        // 1) первый пункт аналогично предыдущим
        // 2) чтобы избавиться от гемора, нам понадобится класс CriteriaQuery<Сюда передаешь класс из директории model, только не тупи все просто, проебешся буду хуесосить>
        // ну и само собой называешь его как-то, рекомендую criteriaQuery, само собой приравниваешь к переменной session, и у нее начинаешь, вызывать методы,
        // а вот какие далее буду говорить, что они делают, может начнешь, искать, что-то новое узнаешь:
        // 2.1)Возвращает экземпляр CriteriaBuilder для создания объектов CriteriaQuery. сылочка вот https://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html
        // 2.2)Создайте экземпляр TypedQuery для выполнения инструкции Java Persistence query language. сылочка таже, не знаешь, что это делает читай,
        // сылка таже, переводчик в помощь, не забудь в параметры передать [Класс].class, вместо класс я думаю, ты понял что написать
        // 3)Обрашаешься к переменной criteriaQuery и вызваешь у нее метод from, в который передаешь [Класс].class, думаю перевод, сам за себя говорит, если шо гугли, будет не лишним
        // 4)Создаешь колекцию(лист) в нее <User> называешь userList, приравниваешь к переменной session, и понеслось гавно по трубам
        // 4.1) вызываешь метод "Создайте экземпляр TypedQuery для выполнения запроса критериев." сылка таже, и передаешь в параметры нашу переменную criteriaQuery
        // 4.2) и шлифуем методом который получаешь лист результатов(если переведешь все на английский, думаю сразу поймешь что за метод)
        // 5) теперь по сути в переменной userList у нас есть все, что нам нужно, открываешь блок try(ловим в catch, что и раньше),
        // обрашаемся к переменной session и вызываем метод по закрытию, а на новой строчке все в то мже теле блока try возвращаем переменную userList,
        // ну и не забываем радоваться, если сделал то без базару мужик с большими яйцами

    }
    @Override
    public void cleanUsersTable() {
        // короче здесь теже пункты, что и в createUsersTable(), ток в запрос передаешь sql для чистки, это не сложно, гуглится быстро

    }
}
